---
published: true
layout: single
title: CS50_2
categories:
  - CS
tags:
  - CS50
  - 컴파일러
  - 정수 오버플로우

toc: true
toc_sticky: true

---

직접 작성하는 코드를 <mark style="background: #FF5582A6;">소스코드</mark> 라고 부른다.  
그리고 그 소스 코드를 컴퓨터가 이해할 수 있는 2진수로 이루어진 코드를 <mark style="background: #BBFABBA6;">머신 코드</mark> 라고 부른다.  
그리고 소스코드 를 머신코드로 바꿔주는 작업을 <mark style="background: #ADCCFFA6;">컴파일러</mark> 라는 프로그램이 수행해준다.  

![](https://raw.githubusercontent.com/Cloudblack/Forpicture/image//img/20220823110946.png)


컴퓨터의 저장장치는 유한한 크기의 비트만 저장할 수 있어 부정확한 결과를 내기도 한다.  

예를들어 부동소수점 처럼  
유한한 저장공간을 효율적으로 활용하기위해  

![](https://raw.githubusercontent.com/Cloudblack/Forpicture/image//img/20220724233824.png)

부호 지수부 가수부로 이루게된다  
쉽게말하면 아무리 큰 숫자도 1의자리.소수점 * 10의 제곱으로 만든다는 것  
왜 이렇게 사용하나면 기존에 사용하던 고정소수점은 정수와 소수부분의 자리수를 고정으로 갖게되고  예를들어 정수와 소수를 5자리씩 갖게된다면 10.0001을 표현하면  
00010.00010 이된다. 전체 자리수가 정해져있다고 생각하면 고정소수점이 얼마나 비효율 적인지 알 수 있다.  
고정소수점은 정확한 수를 기록할 수 있다는 장점이있고  
부동소수점은 부정확할 수 있으나 효율적이라는 장점이있다.  

정수 오버플로우  

기록할 수 있는 최대치를 넘어가게되면 0으로 돌아오게되는 문제이다 예를들어  
세자리를 기록할 수 있는 저장장치가있을때  
999 까지는 표시할수있지만 여기에 1을 추가하게되면  
세자리 밖에 없기때문에 1000이 되는게 아닌  000이 되고만다  
실제로 이런문제가 실생활에서도 있었다.  
어릴때 듣기는했지만 뭔지 모르고 그냥 지나간 Y2K처럼  

```
1999년에 큰 이슈가 되었던 Y2K 문제는 연도를 마지막 두 자리수로 저장했던 관습 때문에 새해가 오면 ‘99’에서 ‘00’으로 정수 오버플로우가 발생하고, 새해가 2000년이 아닌 1900년으로 인식된다는 문제였습니다.

그리고 세계는 수백만 달러를 투자해서 프로그래머들에게 더 많은 메모리를 활용해서 이를 해결하도록 하였습니다.

이는 통찰력 부족으로 발생한 아주 현실적이고 값비싼 문제였습니다.

   

또한 다른 사례로 비행기 보잉 787에서 구동 후 248일이 지나면 모든 전력을 잃는 문제가 있었습니다.

왜냐하면 강제로 안전 모드로 진입하였기 때문입니다.

이는 소프트웨어의 변수가 248일이 지난 뒤에 오버플로우가되어 발생하였기 때문이었습니다.

248일을 1/100초로 계산하면 대략 2의 32제곱이 나옵니다.

보잉을 설계할때 사용한 변수보다 너무 커졌던 것입니다.

이를 해결하기 위해 주기적으로 재가동을 하여 변수를 다시 0으로 리셋했습니다.

```

