---
published: true
layout: single
title: CS50_6
categories: [CS50]
tags:
  - CS50
toc: true
toc_sticky: true
date created: 수요일, 8월 31일 2022
date modified: 수요일, 8월 31일 2022
---

# 배열 크기 조절
3크기의 문자열이있는데  
조금 더 긴 문자열을 만들고싶다면 쉽게 생각하면 그냥 뒤에 하나 더 붙일수도 있지않을까 생각 할 수 있다.  
하지만 실제로는 이미 배열된 문자열 앞뒤로 꽉 차있을 수도있다.

그러면 새로운 크기의 배열을 만들고 하나씩 옮기고 기존을 제거하는 방식으로 크기를 조절해야한다.

## 연결리스트
하지만 이렇게하면 비효율적이다.  
그래서 떨어진 값들을 연결하는게 <mark style="background: #FF5582A6;">연결 리스트</mark> 이다  
![](https://raw.githubusercontent.com/Cloudblack/Forpicture/image//img/20220831173434.png)  
연결리스트는 값이 있고 다음 공간에 다음 위치의 주소(포인터)를 저장해둔다 .

고정된 배열은 바로옆에 붙어있어 적은 메모리를 먹고 빠르게 접근할 수있다. 하지만 유연성이 떨어진다  
반대로 연결리스트는 떨어진 값들도 연결할 수 있어 유연하지만 다음 주소를 연결해줘야하는 만큼 메모리를 차지하고 속도도 떨어진다.  
또 뒤쪽을 볼려면 무조건 처음부터 찾아가야한다.(임의 접근을 할 수 없다.)

## 트리
![](https://raw.githubusercontent.com/Cloudblack/Forpicture/image//img/20220831175800.png)  
트리는 1차원으로 이루어진 연결리스트를 2차원으로 표현한다  
위의 사진은 이진 검색 트리이다  
원래 연결리스트에서는 하나씩 살펴봐야해서 이진 검색을 할 수없지만 이진 검색 트리는 가능하다  
루트를 기준으로 left와 right node를 갖게되고  
작은 것은 left 큰 것은 right로 위치하게된다.  
이진 검색에 한해서는 배열에 비해 유연하면서 빠른 속도를 갖게된다  
물론 메모리까지는 잡지못했다.

## 해시테이블
해시테이블은 연결 리스트의 배열이다  
해시 함수라는 것을 통해 어떤 주소에 입력되는지가 결정된다  
![](https://raw.githubusercontent.com/Cloudblack/Forpicture/image//img/20220831192307.png)

## 트라이
**‘트라이’**는 기본적으로 ‘트리’ 형태의 자료 구조입니다.

특이한 점은 **각 노드가 ‘배열’**로 이루어져있다는 것입니다.

예를 들어 영어 알파벳으로 이루어진 문자열 값을 저장한다고 한다면 이 노드는 a부터 z까지의 값을 가지는 배열이 됩니다.

그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)를 가리킵니다. 

  

아래 그림과 같이 Hermione, Harry, Hagrid 세 문자열을 트라이에 저장해보겠습니다.

루트 노드를 시작으로 각 화살표가 가리키는 알파벳을 따라가면서 노드를 이어주면 됩니다.

  

![](https://cs50.harvard.edu/x/2020/notes/5/trie.png)  

  

위와 같은 트라이에서 값을 검색하는데 걸리는 시간은  문자열의 길이에 의해 한정됩니다.

단순히 문자열의 각 문자를 보며 트리를 탐색해나가기만 하면 되니까요.

일반적인 영어 이름의 길이를 **n**이라고 했을 때, 검색 시간은 O(n)이 되지만, 대부분의 이름은 그리 크지 않은 **상수값**(예, 20자 이내)이기 때문에 O(1)이나 마찬가지라고 볼 수 있습니다.

## 큐
큐는 메모리 구조에서 살펴봤듯이 값이 아래로 쌓이는 구조입니다.

값을 넣고 뺄 때 <mark style="background: #FF5582A6;">선입 선출</mark>  또는 <mark style="background: #FFB86CA6;">FIFO</mark> 라는 방식을 따르게 됩니다. 가장 먼저 들어온 값이 가장 먼저 나가는 것이죠.

은행에서 줄을 설 때 가장 먼저 줄을 선 사람이 가장 먼저 업무를 처리하게 되는 것과 동일합니다.

<mark style="background: #FFF3A3A6;">배열이나 연결 리스트</mark> 를 통해 구현 가능합니다.

  

  

## 스택
반면 스택은 역시 메모리 구조에서 살펴봤듯이 값이 위로 쌓이는 구조입니다.

따라서 값을 넣고 뺄 때 <mark style="background: #FF5582A6;">후입 선출</mark> 또는 <mark style="background: #FF5582A6;">‘LIFO’</mark> 라는 방식을 따르게 됩니다. 가장 나중에 들어온 값이 가장 먼저 나가는 것이죠.

뷔페에서 접시를 쌓아 뒀을 때 사람들이 가장 위에 있는(즉, 가장 나중에 쌓인) 접시를 가장 먼저 들고 가는 것과 동일합니다.

역시 <mark style="background: #FFF3A3A6;">배열이나 연결 리스트</mark> 를 통해 구현 가능합니다.

  

  

## 딕셔너리
딕셔너리는 <mark style="background: #FF5582A6;">키</mark> 와 <mark style="background: #FFB86CA6;">값</mark> 이라는 요소로 이루어져 있습니다.

‘<mark style="background: #FF5582A6;">키</mark> ’에 해당하는 ‘<mark style="background: #FFB86CA6;">값</mark> ’을 저장하고 읽어오는 것이죠. 마치 대학교에서 ‘학번’에 따라서 ‘학생’이 결정되는 것과 동일합니다.

일반적인 의미에서 <mark style="background: #FFF3A3A6;">해시 테이블</mark> 과 동일한 개념이라고도 볼 수 있습니다.
